#' Prepare data for Thurstonian IRT models
#'
#' @param data An object of class \code{data.frame} containing data of all
#'   variables used in the model.
#' @param blocks Object of class \code{TIRTblocks} generated by
#'   \code{\link{set_block}} indicating which items belong to which block, trait
#'   and more. Ignored if data already contains information on the blocks.
#' @param direction Indicates if \code{"smaller"} (the default) or
#'   \code{"larger"} input values are considered as indicating the favored
#'   answer.
#' @param partial A flag to indicate whether partial comparisons are allowed.
#'
#' @return A \code{data.frame} in a specific format and with attributes ready
#'   for use with other functions of the \pkg{ThurstonianIRT} package.
#'
#' @export
make_TIRT_data <- function(data, blocks, direction = c("smaller", "larger"),
                           partial = FALSE) {
  if (is.TIRTdata(data)) {
    return(data)
  }
  direction <- match.arg(direction)
  partial <- as_one_logical(partial)
  stopifnot(is.TIRTblocks(blocks))
  blocks <- blocks$blocks
  data <- as.data.frame(data)
  npersons <- nrow(data)
  nblocks <- length(blocks)
  nitems_per_block <- length(blocks[[1]]$items)
  ncomparisons <- (nitems_per_block * (nitems_per_block - 1)) / 2
  items_all <- ulapply(blocks, "[[", "items")
  nitems <- length(items_all)
  if (nitems != nitems_per_block * nblocks) {
    stop("All blocks should contain the same number of items.")
  }
  traits_all <- unique(ulapply(blocks, "[[", "traits"))
  ntraits <- length(traits_all)
  out <- tibble::tibble(
    person = rep(1:npersons, ncomparisons * nblocks),
    block = rep(1:nblocks, each = npersons * ncomparisons),
    comparison = rep(rep(1:ncomparisons, each = npersons), nblocks)
  )
  for (i in seq_len(nblocks)) {
    items <- blocks[[i]]$items
    item1 <- rep_comp(items, 1, nitems_per_block)
    item2 <- rep_comp(items, 2, nitems_per_block)
    traits <- blocks[[i]]$traits
    trait1 <- rep_comp(traits, 1, nitems_per_block)
    trait2 <- rep_comp(traits, 2, nitems_per_block)
    signs <- blocks[[i]]$signs
    sign1 <- rep_comp(signs, 1, nitems_per_block)
    sign2 <- rep_comp(signs, 2, nitems_per_block)

    fblock <- (i - 1) * nitems_per_block
    rows <- out$block == i
    comparison <- out[rows, ]$comparison
    out[rows, "itemC"] <- comparison + fblock
    out[rows, "trait1"] <- trait1[comparison]
    out[rows, "trait2"] <- trait2[comparison]
    out[rows, "item1"] <- item1[comparison]
    out[rows, "item2"] <- item2[comparison]
    out[rows, "sign1"] <- sign1[comparison]
    out[rows, "sign2"] <- sign2[comparison]

    response1 <- unname(do.call(c, data[, item1]))
    response2 <- unname(do.call(c, data[, item2]))
    if (direction == "smaller") {
      response <- as.numeric(case_when(
        response1 < response2 ~ 1,
        response1 > response2 ~ 0,
        TRUE ~ NaN
      ))
    } else if (direction == "larger") {
      response <- as.numeric(case_when(
        response1 > response2 ~ 1,
        response1 < response2 ~ 0,
        TRUE ~ NaN
      ))
    }
    out[rows, "response1"] <- response1
    out[rows, "response2"] <- response2
    out[rows, "response"] <- response
  }
  out$item1 <- factor(out$item1, levels = items_all)
  out$item2 <- factor(out$item2, levels = items_all)
  out$trait1 <- factor(out$trait1, levels = traits_all)
  out$trait2 <- factor(out$trait2, levels = traits_all)

  is_nan <- is.nan(out$response)
  any_nan <- any(is_nan)
  if (any_nan) {
    if (!partial) {
      stop("Please set 'partial = TRUE' when using partial comparisons.")
    }
    out <- filter(out, !is_nan)
  } else {
    partial <- FALSE
  }

  # check for items being used multiple times in the test
  item_names <- ulapply(blocks, "[[", "names")
  dupl_item_nums <- which(duplicated(item_names))
  dupl_item_names <- unique(item_names[dupl_item_nums])
  dupl_items <- named_list(dupl_item_names)
  for (i in seq_along(dupl_items)) {
    dupl_items[[i]] <- which(item_names == dupl_item_names[i])
  }
  # add attributes to the returned object
  structure(out,
    npersons = npersons,
    ntraits = ntraits,
    nblocks = nblocks,
    nitems = nitems,
    nitems_per_block = nitems_per_block,
    signs = ulapply(blocks, "[[", "signs"),
    dupl_items = dupl_items,
    traits = unique(ulapply(blocks, "[[", "traits")),
    partial = partial,
    # TODO: allow for other families
    family = "bernoulli",
    class = c("TIRTdata", class(out))
  )
}

#' Prepare data for Thurstonian IRT models fitted with
#' lavaan or Mplus
#'
#' @inheritParams fit_TIRT_stan
#'
#' @return A list of data ready to be passed to \pkg{lavaan}
#' or \pkg{Mplus}.
#'
#' @import dplyr
#' @importFrom magrittr '%>%'
#' @export
make_sem_data <- function(data) {
  if (!is.TIRTdata(data)) {
    stop("'data' should be of class 'TIRTdata'. See ?make_TIRT_data")
  }
  data <- convert_factors(data)
  att <- attributes(data)
  npersons <- att[["npersons"]]
  ntraits <- att[["ntraits"]]
  nblocks <- att[["nblocks"]]
  ncols <- ntraits * (ntraits - 1) / 2 * nblocks
  data %>%
    mutate(itemC = paste0("i", .data$item1, "i", .data$item2)) %>%
    mutate(itemC = factor(.data$itemC, levels = unique(.data$itemC))) %>%
    select("person", "itemC", "response") %>%
    tidyr::spread(key = "itemC", value = "response") %>%
    select(-.data$person)
}

convert_factors <- function(data) {
  # data and code generating functions require
  # items and traits to be numeric
  stopifnot(is.TIRTdata(data))
  for (v in c("item1", "item2", "trait1", "trait2")) {
    data[[v]] <- as.integer(data[[v]])
  }
  data
}

#' Prepare blocks of items
#'
#' Prepare blocks of items and incorporate information
#' about which item belongs to which trait
#'
#' @param items Names of item comparisons to be combined
#' into one block. Should correspond to variables in the data.
#' @param traits Names of the traits to which each item belongs
#' @param names Optional names of the items in the output.
#' Can be used to equate parameters of items across blocks,
#' if the same item was used in different blocks.
#' @param signs Expected signs of the item loadings (1 or -1).
#'
#' @examples
#' set_block(
#'   items = c("i1i2", "i1i3", "i2i3"),
#'   traits = c("A", "B", "C")
#' ) +
#' set_block(
#'   items = c("i4i5", "i4i6", "i5i6"),
#'   traits = c("A", "B", "C")
#' )
#'
#' @export
set_block <- function(items, traits, names = items, signs = 1) {
  stopifnot(length(items) == length(traits))
  items <- as.character(items)
  traits <- as.character(traits)
  names <- as.character(names)
  if (length(signs) == 1L) {
    signs <- rep(signs, length(items))
  }
  stopifnot(length(items) == length(signs))
  signs <- sign(signs)
  out <- list(blocks = list(nlist(items, traits, names, signs)))
  structure(out, class = "TIRTblocks")
}

#' @rdname set_block
#' @export
empty_block <- function() {
  structure(list(blocks = list()), class = "TIRTblocks")
}

#' @export
"+.TIRTblocks" <- function(e1, e2) {
  stopifnot(is.TIRTblocks(e2))
  e1$blocks <- c(e1$blocks, e2$blocks)
  e1
}

is.TIRTdata <- function(x) {
  inherits(x, "TIRTdata")
}

is.TIRTblocks <- function(x) {
  inherits(x, "TIRTblocks")
}

rep_comp <- function(x, comp, nitems_per_block) {
  # generate comparisons of first vs. second items, traits etc.
  # Args:
  #   x: vector of names of items, traits, etc.
  #   comp: first or second comparison?
  stopifnot(comp %in% 1:2)
  if (comp == 1) {
    out <- rep(x[1:(nitems_per_block - 1)], (nitems_per_block - 1):1)
  } else {
    out <- ulapply(2:nitems_per_block, function(y) x[y:nitems_per_block])
  }
  out
}

check_family <- function(family, software = NULL) {
  options <- family_options(software)
  match.arg(family, options)
}

family_options <- function(software = NULL) {
  if (is.null(software)) {
    all_ops <- c("bernoulli", "cumulative", "beta", "normal")
    return(all_ops)
  }
  software <- match.arg(software, c("stan", "lavaan", "mplus"))
  if (software == "stan") {
    out <- c("bernoulli", "cumulative", "beta", "normal")
  } else if (software == "lavaan") {
    out <- c("bernoulli", "normal")
  } else if (software == "mplus") {
    out <- c("bernoulli")
  }
  out
}
